// Copyright (c) 2023 Cloudflare, Inc. All rights reserved.

//! Delayed-input FLP.

use prio::{
    field::{random_vector, FftFriendlyFieldElement},
    flp::{gadgets::Mul, FlpError, Gadget, Type},
};
use std::marker::PhantomData;

/// Base FLP for the delayed-input FLP of Appendix B.
///
/// Let `(s, t, delta)` denote the input. Looking ahead, `s, t` are the sums of the IDPF outputs
/// and `delta` is the encoding randomness generated by the Client. The validity circuit for this
/// FLP is as follows:
///
/// ```text
/// C(s, t, delta, r) = (r * s(s-1) + r^2 * (s*delta - t))^2
/// ```
///
/// where `r` denotes the joint ramomndess. The output of this circuit is `0` if `s == 1` and `t ==
/// Detla` (the IDPF prefixes include the on-path index)  or `s == 0` and `t == 0` (the IDPF
/// prefixes do not include the on-path prefix).
#[derive(Clone, Debug, PartialEq, Eq)]
struct BlindRangeCheck<F> {
    phantom: PhantomData<F>,
}

impl<F: FftFriendlyFieldElement> BlindRangeCheck<F> {
    fn new() -> Self {
        Self {
            phantom: PhantomData,
        }
    }
}

impl<F: FftFriendlyFieldElement> Type for BlindRangeCheck<F> {
    // Prio3's algorithm identifier is inherited from the underlying [`Type`]. Since we don't use
    // this FLP to construct Prio3, this ID will be ignored.
    const ID: u32 = unreachable!();
    type Measurement = ();
    type AggregateResult = ();
    type Field = F;

    fn encode_measurement(&self, _value: &()) -> Result<Vec<F>, FlpError> {
        unreachable!("we don't need an affine aggregatable encoding for this application")
    }

    fn decode_result(&self, _data: &[F], _num_measurements: usize) -> Result<(), FlpError> {
        unreachable!("we don't need an affine aggregatable encoding for this application")
    }

    fn gadget(&self) -> Vec<Box<dyn Gadget<F>>> {
        vec![Box::new(Mul::new(3))]
    }

    fn valid(
        &self,
        g: &mut Vec<Box<dyn Gadget<F>>>,
        input: &[F],
        joint_rand: &[F],
        num_shares: usize,
    ) -> Result<F, FlpError> {
        let mut mul = |left, right| -> Result<F, FlpError> { g[0].call(&[left, right]) };
        let scaled_one = F::one() / F::from(num_shares.try_into().unwrap());
        let r = joint_rand[0];
        let s = input[0];
        let t = input[1];
        let delta = input[2];
        let range_check = mul(s, s - scaled_one)?;
        let equal_check = mul(s, delta)? - t;
        let mut out = range_check + r * equal_check;
        out *= r;
        out = mul(out, out)?;
        Ok(out)
    }

    fn truncate(&self, _input: Vec<F>) -> Result<Vec<F>, FlpError> {
        unreachable!("we don't need an affine aggregatable encoding for this application")
    }

    fn input_len(&self) -> usize {
        3
    }

    fn proof_len(&self) -> usize {
        9
    }

    fn verifier_len(&self) -> usize {
        4
    }

    fn output_len(&self) -> usize {
        unreachable!("we don't need an affine aggregatable encoding for this application")
    }

    fn joint_rand_len(&self) -> usize {
        1
    }

    fn prove_rand_len(&self) -> usize {
        2
    }

    fn query_rand_len(&self) -> usize {
        1
    }
}

/// Proof generation algorithm. Generate a proof that verifies for delayed inputs `(s, t)` for
/// which `s == 1` and `t == delta` or `s == 0` and `t == 0`. We say the input is delayed because
/// the proof verifies for multiple values.
pub fn prove<F: FftFriendlyFieldElement>(
    delta: F,
    joint_rand: &[F; 2],
) -> Result<Vec<F>, FlpError> {
    let flp = BlindRangeCheck::new();
    let mut proof = Vec::with_capacity(2 * flp.proof_len());

    // NOTE To protect the prover from timing side channels, we would need to make sure the runtime
    // of all codepaths are independent of the value of `order`. this includes indexing into
    // `joint_rand` and the swapping the proofs.
    let order = rand::random::<bool>();

    // Generate two FLPs: one for an IDPF output that includes the on-path index...
    let on_path_proof = flp.prove(
        &[F::one(), delta, delta],
        &random_vector(flp.prove_rand_len()).expect("rng failed"),
        &[joint_rand[order as usize]],
    )?;

    // ... and another for an IPDF output that excludes the off-path indexo.
    let off_path_proof = flp.prove(
        &[F::zero(), F::zero(), delta],
        &random_vector(flp.prove_rand_len()).expect("rng failed"),
        &[joint_rand[1 - (order as usize)]],
    )?;

    // To protect privacy, randomly swap the proofs.
    if order {
        proof.extend(on_path_proof);
        proof.extend(off_path_proof);
    } else {
        proof.extend(off_path_proof);
        proof.extend(on_path_proof);
    }

    Ok(proof)
}

/// Query generation algorithm. Generate a verifier string for verifying delayed input `(s, t)`.
pub fn query<F: FftFriendlyFieldElement>(
    s: F,
    t: F,
    delta: F,
    proof: &[F],
    query_rand: &[F; 2],
    joint_rand: &[F; 2],
    num_shares: usize,
) -> Result<Vec<F>, FlpError> {
    let flp = BlindRangeCheck::new();
    let mut verifier = Vec::with_capacity(2 * flp.verifier_len());

    verifier.extend(flp.query(
        &[s, t, delta],
        &proof[..flp.proof_len()],
        &[query_rand[0]],
        &[joint_rand[0]],
        num_shares,
    )?);

    verifier.extend(flp.query(
        &[s, t, delta],
        &proof[flp.proof_len()..],
        &[query_rand[1]],
        &[joint_rand[1]],
        num_shares,
    )?);

    Ok(verifier)
}

/// Decision algorithm.
pub fn decide<F: FftFriendlyFieldElement>(verifier: &[F]) -> Result<bool, FlpError> {
    let flp = BlindRangeCheck::new();

    // One of the proofs should be valid.
    Ok(flp.decide(&verifier[..flp.verifier_len()])?
        | flp.decide(&verifier[flp.verifier_len()..])?)
}

#[cfg(test)]
mod tests {
    use super::*;
    use prio::field::{Field128, FieldElement};

    fn split<F: FieldElement>(vec: impl AsRef<[F]>) -> (Vec<F>, Vec<F>) {
        random_vector(vec.as_ref().len())
            .unwrap()
            .iter()
            .zip(vec.as_ref().iter())
            .map(|(r, i)| (*r, *i - *r))
            .unzip()
    }

    fn combine<F: FieldElement>(share_0: impl AsRef<[F]>, share_1: impl AsRef<[F]>) -> Vec<F> {
        share_0
            .as_ref()
            .iter()
            .zip(share_1.as_ref().iter())
            .map(|(left, right)| *left + *right)
            .collect()
    }

    fn test_flp<T: Type>(flp: &T, input: impl AsRef<[T::Field]>) {
        let joint_rand = random_vector(flp.joint_rand_len()).unwrap();
        let prove_rand = random_vector(flp.prove_rand_len()).unwrap();
        let query_rand = random_vector(flp.query_rand_len()).unwrap();

        // Generate and verify proof.
        let proof = flp.prove(input.as_ref(), &prove_rand, &joint_rand).unwrap();
        let verifier = flp
            .query(input.as_ref(), &proof, &query_rand, &joint_rand, 1)
            .unwrap();
        assert_eq!(proof.len(), flp.proof_len());
        assert_eq!(verifier.len(), flp.verifier_len());
        assert!(flp.decide(&verifier).unwrap());

        // Test for full linearity.
        let (input_share_0, input_share_1) = split(input);
        let (proof_share_0, proof_share_1) = split(proof);
        let verifier_share_0 = flp
            .query(&input_share_0, &proof_share_0, &query_rand, &joint_rand, 2)
            .unwrap();
        let verifier_share_1 = flp
            .query(&input_share_1, &proof_share_1, &query_rand, &joint_rand, 2)
            .unwrap();
        let verifier = combine(verifier_share_0, verifier_share_1);
        assert!(flp.decide(&verifier).unwrap());
    }

    #[test]
    fn base_flp() {
        let flp = BlindRangeCheck::<Field128>::new();

        // Test valid inputs.
        let delta = random_vector(1).unwrap()[0];
        let off_path = [Field128::zero(), Field128::zero(), delta];
        let on_path = [Field128::one(), delta, delta];
        test_flp(&flp, off_path);
        test_flp(&flp, on_path);

        // Test invalid inputs.
        let joint_rand = random_vector(flp.joint_rand_len()).unwrap();
        let prove_rand = random_vector(flp.prove_rand_len()).unwrap();
        let query_rand = random_vector(flp.query_rand_len()).unwrap();
        let input = [Field128::zero(), Field128::one(), delta];
        assert!(!flp
            .decide(
                &flp.query(
                    &input,
                    &flp.prove(&input, &prove_rand, &joint_rand,).unwrap(),
                    &query_rand,
                    &joint_rand,
                    1,
                )
                .unwrap()
            )
            .unwrap());
        let input = random_vector(3).unwrap();
        assert!(!flp
            .decide(
                &flp.query(
                    &input,
                    &flp.prove(&input, &prove_rand, &joint_rand,).unwrap(),
                    &query_rand,
                    &joint_rand,
                    1,
                )
                .unwrap()
            )
            .unwrap());

        // Test malformed proof.
        let mut proof = flp.prove(&input, &prove_rand, &joint_rand).unwrap();
        proof[0] += Field128::one();
        assert!(!&flp
            .decide(
                &flp.query(&input, &proof, &query_rand, &joint_rand, 1)
                    .unwrap()
            )
            .unwrap());
    }

    #[test]
    fn delayed_flp() {
        let rand = random_vector::<Field128>(5).unwrap();
        let delta = rand[0];
        let joint_rand = [rand[1], rand[2]];
        let query_rand = [rand[3], rand[4]];
        let proof = prove(delta, &joint_rand).unwrap();

        // Test on-path input.
        let verifier = query(
            Field128::one(),
            delta,
            delta,
            &proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();
        assert!(decide(&verifier).unwrap());

        // Test off-path input.
        let verifier = query(
            Field128::zero(),
            Field128::zero(),
            delta,
            &proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();
        assert!(decide(&verifier).unwrap());

        // Test linearity.
        let (input_share_0, input_share_1) = split([Field128::zero(), Field128::zero(), delta]);
        let (proof_share_0, proof_share_1) = split(&proof);
        let verifier_share_0 = query(
            input_share_0[0],
            input_share_0[1],
            input_share_0[2],
            &proof_share_0,
            &query_rand,
            &joint_rand,
            2,
        )
        .unwrap();
        let verifier_share_1 = query(
            input_share_1[0],
            input_share_1[1],
            input_share_1[2],
            &proof_share_1,
            &query_rand,
            &joint_rand,
            2,
        )
        .unwrap();
        let verifier = combine(verifier_share_0, verifier_share_1);
        assert!(decide(&verifier).unwrap());

        // Try verifying invalid input.
        let verifier = query(
            Field128::one(),
            Field128::one(),
            Field128::one(), // Does not match `delta`
            &proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();
        assert!(!decide(&verifier).unwrap());

        // Try verifying invalid input + proof.
        let mut bad_proof = proof.clone();
        bad_proof[0] += Field128::one();
        let verifier = query(
            Field128::one(),
            Field128::one(),
            Field128::one(), // Does not match `delta`
            &proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();
        assert!(!decide(&verifier).unwrap());
    }

    // This test demonstrates that, if the delayed input is valid, the Client can fiddle with the
    // proof without being detected. This "attack" does not violate soundness, as our definition of
    // (D)FLP soundness only measures the attacker's adventage in tricking the verifer into
    // accepting an invalid input. (See Figure 2.)
    //
    // Nevertheless, it is notable because standard FLPs will typically fail to verify a valid
    // input if the proof is malformed. (Of course, FLP soundness does not guarantee this.)
    #[test]
    fn delayed_flp_bad_proof_valid_input() {
        let rand = random_vector::<Field128>(5).unwrap();
        let delta = rand[0];
        let joint_rand = [rand[1], rand[2]];
        let query_rand = [rand[3], rand[4]];

        let mut bad_proof = prove(delta, &joint_rand).unwrap();
        bad_proof[0] += Field128::one();

        let off_path_verifier = query(
            Field128::zero(),
            Field128::zero(),
            delta,
            &bad_proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();

        let on_path_verifier = query(
            Field128::one(),
            delta,
            delta,
            &bad_proof,
            &query_rand,
            &joint_rand,
            1,
        )
        .unwrap();

        // We expect exactly one of these tests to fail.
        assert!(decide(&off_path_verifier).unwrap() ^ decide(&on_path_verifier).unwrap());
    }
}
